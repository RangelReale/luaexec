
=== Table of contents ===

 - 1. [[#about : About LuaExec]]
  - 1.1. [[#overview : Overview]]
  - 1.2. [[#demarcation : What it does and doesn't]]
  - 1.3. [[#implementation : Implementation details]]
  - 1.4. [[#status : Status, outlook]]
  - 1.5. [[#license : License]]
  - 1.6. [[#links : Authors, links and downloads]]

 - 2. [[#buildinstall : Installation]]
  - 2.1. [[#requirements : Requirements]]
  - 2.2. [[#buildenv : Adjusting the build environment]]
  - 2.3. [[#builing : Building]]
  - 2.4. [[#installation : Installation]]
  - 2.5. [[#gendoc : Documentation system]]

 - 3. [[#examples : Examples]]
  - 3.1 [[#tests : Tests]]
  - 3.2 [[#httpserver : HTTP server]]

 - 4. [[#tutorial : Quickstart tutorial]]

=== Reference ===

 * [[manual.html#tek.lib.exec : LuaExec module reference]]
 * [[manual.html : Complete class and library reference manual]]
 * [[changes.html : Changelog]]
 * [[copyright.html : COPYRIGHT]]


---------------------------------------------------------------------

==( about : 1. About LuaExec )==

===( overview : 1.1 Overview )===

LuaExec is another take on multitasking for Lua. 

LuaExec is mainly focused on general applicability, simplicity and
concise semantics. It provides multiple threads of execution in the
most abstract sense, behaving understandably, platform-independently
and unencumbered by OS specific details.

===( demarcation : 1.2 What it does and doesn't )===

 * runs a Lua interpreter per task
 * is recursive, a child task can itself require the module, run
 child tasks, and see all other tasks
 * data exchange using messages, signals, arguments and return values
 * allows to synchronize on: task completion, signals, messages
 * abstract signals: a, t, c, m (abort, terminate, child, message)
 * tasks can find each other by name or by parent
 * no shared data, no marshalling, this is at the user's discretion
 * no operating system details (e.g. priorities)

===( implementation : 1.3 Implementation details )===

 * LuaExec is a regular module using only the legal Lua API.
 * It should work with Lua 5.1, 5.2, 5.3, and LuaJIT2.0 on POSIX and
 Windows. Not all combinations are fully tested yet.
 * Child tasks are subject to garbage collection in their parent
 that created them. Their underlying OS threads are always joined
 and ''never killed forcibly'', and all resources requested in any
 task are meant to be returned, at the latest through garbage
 collection.
 * A Lua error in a task raises a signal, a (abort), that is by
 default propagated to the parent task.
 * Child tasks and tasks that spawned children are, by default,
 supplied with a debug hook that checks for the abortion signal,
 where it raises an error, signals its parent, and so forth.
 * The hook can be disabled on a per-task basis. In such tasks
 abortion strikes only when they are suspended in wait, sleep etc.

===( status : 1.4. Status, outlook )===

This project is a prototype and request for comments. Additions,
suggestions, improvements, bug fixes are likely needed and welcome.
Performance was no consideration yet. In its current stage LuaExec
is about getting semantics right. Some considerations:

 * Because LuaExec is recursive in that child tasks can create new
 tasks that can see other tasks (and can be seen by other tasks),
 LuaExec could easily provide a shared data or registry mechanism.
 This is currently being investigated. 

 * LuaExec's protocol and API should remain (or become) transparent
 as to whether it is implemented as threads or processes, or as
 threads or processes on different hosts.
 
 * Support for serialization or marshalling

 * Given sufficient interest, this library might be extended in a way
 that other Lua modules and libraries can be written against
 LuaExec's C and Lua APIs, so that future Lua sockets and I/O,
 libraries and applications can converge and be synchronized on
 atomically in a platform-independent, Lua-ish way.
 
This project is a spin-off from the
[[tekUI project][http://tekui.neoscientists.org/]]. The LuaExec 0.80
module is fully contained in (but usable independently of) tekUI
version 1.11. The reason for outsourcing was to have a separate
testbed and package that is unencumbered by the requirements and
complexity of graphical input and output. There are a few examples
in this package that can be run against tekUI, and there are a few
more tasks examples in the tekUI package.

===( license : 1.5. License )===

LuaExec is free software under the same license as Lua itself: It can
be used for both academic and commercial purposes at no cost. It
qualifies as Open Source software, and its license is compatible with
the GPL – see [[copyright][copyright.html]]. Additional components
are available under a commercial license – see below.


===( links : 1.6. Authors, links and downloads )===

Authors:
 - Timm S. Müller <tmueller at schulze-mueller.de>

Open source project website:
 - http://luaexec.neoscientists.org/

Releases:
 - http://luaexec.neoscientists.org/releases/

Online source code repository:
 - http://hg.neoscientists.org/luaexec


---------------------------------------------------------------------

==( buildinstall : 2. Building and installing )==

===( requirements : 2.1. Requirements )===

 * Lua 5.1, 5.2, 5.3, LuaJIT 2.x
 * GCC or LLVM/clang
 * MinGW for building for the Windows platform

Only for the webserver example and documentation generator:
Lua 5.2 and 5.3 must be compiled with {{LUA_COMPAT_MODULE}}.

==== External Lua modules ====

LuaExec does not strictly depend on any external Lua modules. The
following modules are supported:

 * [[LuaFileSystem][http://www.keplerproject.org/luafilesystem/]]
 for the HTTP server example and documentation generator
 * [[LuaSocket][http://w3.impa.br/~diego/software/luasocket/]]
 for the HTTP server example
 
===( buildenv : 2.2. Adjusting the build environment )===

If building fails for you, you may have to adjust the build
environment, which is located in the {{config}} file on the topmost
directory level. Supported build tools are {{gmake}} (common under
Linux) and {{pmake}} (common under FreeBSD). More build options and
peculiarities are documented in the tekUI package, many of which
apply to the LuaExec package as well.

==== BSD notes ====

On FreeBSD and NetBSD you need a Lua binary which is linked with the
{{-pthread}} option, as LuaExec is using multithreaded code in shared
libraries, which are dynamically loaded by the interpreter.

===( building : 2.3. Building )===

To see all build targets, type

  # make help

The regular build procedure is invoked with

  # make all

===( installation : 2.4. Installation )===

A system-wide installation of LuaExec is not strictly required. Once
it is built, it can be worked with and developed against, as long as
you stay in the top-level directory of the distribution; all required
modules will be found if programs are started from there.

If staying in the top-level directory is not desirable, then LuaExec
must be installed globally. By default, the installation paths are

 - {{/usr/local/lib/lua/5.1}}
 - {{/usr/local/share/lua/5.1}}

It is not unlikely that this is different from what is common for
your operating system, distribution or development needs, so be sure
to adjust these paths in the {{config}} file. The installation is
conveniently invoked with

  # sudo make install
  
===( gendoc : 2.5 Documentation system )===

LuaExec comes with a documentation generator. It is capable of
generating a function reference and hierarchical class index from
specially crafted comments in the source code. To regenerate the
full documentation, invoke

  # make docs

Note that you need
[[LuaFileSystem][http://www.keplerproject.org/luafilesystem/]] for
the document generator to process the file system hierarchy.


---------------------------------------------------------------------

==( examples : 3. Examples )==

===( tests : 3.1 Tests )===

Tests are under {{bin/task/}}.

===( httpserver : 3.2 HTTP Server example )===

One of the use cases LuaExec was developed against was to supply
a regular Lua application with an inbuilt HTTP server. It can be
run in the background like this:

  local exec = require "tek.lib.exec"
  local httpd = exec.run(function()
    require "tek.class.httpd":new {
      Listen = arg[1], DocumentRoot = "doc"
    }:run()
  end, arg[1] or "localhost:8080")
  -- ... do something else ...
  httpd:terminate() -- or httpd:join()

To start it serving LuaExec's documentation (default localhost:8080):

  # bin/webserver.lua [host:port]

It requires luasocket and lfs. The server itself is not
multithreaded, due to limitations of the current Lua library
ecosystem, but it supports copas/coxpcall if available. 

These links should work when you have loaded this document from the
provided HTTP server:

 * CGI test page: [[/webserver/testcgi.lua]]
 * Formtest Lua page: [[/webserver/formtest.lhtml]]
 * Webserver control Lua page: [[/webserver/control.lhtml]]

Please note that the HTTP/1.1 part of the server was not thoroughly
written against specifications. It is included as an example.


---------------------------------------------------------------------

==( tutorial : 4. Quickstart tutorial )==

For the first part of this tutorial, please use Lua in interactive
mode, because this is going to be fun, and hopefully instructive!
Start off by requiring the LuaExec module:

  # lua
  > exec = require "tek.lib.exec"

What's our task's name?

  > print(exec.getname())
  => main

Sleep a second (1000 milliseconds):

  > exec.sleep(1000)

Now to starting a new task:

  > exec.run(function() end)
  =>
  
Nothing happened? Well, it probably just ran and exited.
Let's have it do something:

  > exec.run(function() print "hello" end)
  => hello

Seems reasonable. Now let's have it do some work:

  > exec.run(function() while true do end end)
  
So far, so good. Do you notice some change in the behavior of your
computer? Probably not. Ok, then try it again...

  > exec.run(function() while true do end end)

Still nothing? Then try this:
  
  > for i = 1, 4 do exec.run(function() while true do end end) end

Some fans spinning up possibly? 

I think it's time to quit interactive mode now rather quickly.
I hope your Lua interpreter has proper interactive mode, so that
it is orderly closed down and you see the intended effect.
Press CTRL-D now (not CTRL-C):

  > 
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?
  luatask: received abort signal
  stack traceback:
          stdin:1: in function <stdin:1>
          [C]: ?

Each of the tasks started above running an infinite loop should now
receive an abortion signal from Lua closing down and performing
garbage collection. This causes each task to raise an error, and
consequently to report that error. This is a very important
aspect of LuaExec. (And by dissipating heat we just may have helped
the universe to approach its destiny a little sooner, but this
remains to be seen.)

The next examples are performed in scripts. To reiterate
what was said above, run the following script. You'll get a stack trace from the child that was running,
because it did not finish voluntarily when the main program
was ending:

  local exec = require "tek.lib.exec"
  exec.run(function() 
    while true do end
  end)
  => 
  luatask: received abort signal
  stack traceback:
          bin/tutorial.lua:3: in function <bin/tutorial.lua:2>
          [C]: ?

On the other hand, if it ''does'' shut down voluntarily, everything
remains silent:

  local exec = require "tek.lib.exec"
  exec.run(function() 
    print "hello"
  end)
  exec.sleep(100)
  =>
  
I have added the last line to drive home that message, because your
friggin' operating system could theoretically decide to postpone
execution of the child task a bit, and we ended up with an error
and stracktrace nonetheless.

Note that although this is the plushy world of Lua, and LuaExec tries
its best to hide the nastiness of multithreaded programming from you,
trailing behind a bunch of dangling threads is by no means an
encouraged programming technique. What ''is'' encouraged is that you
synchronize on the end of the thread. This also allows you to take
delivery of return values:

  local exec = require "tek.lib.exec"
  local c = exec.run(function()
    return "successful", "indeed"
  end)
  print(c:join())
  =>
  true    successful      indeed

Next we should ask ourselves what threads are actually good for.
Especially in the Lua world this seems to be hotly debated -

In computations, actually, it is difficult to put them to good use,
but matters improved a bit in that regard, with projects like
SETI@home, digging for bitcoins, and so on. There are enough
CPU cycles to be wasted in fun computations, especially if you run
them in a scripting language. Wouldn't it be a pity if we couldn't
saturate eight cores from a small Lua script?

Irony aside, threads have always been useful for long-running
tasks, regardless of their computational demand, and they are
even more useful if they are bound to I/O operations that are precisely
''not'' computationally demanding, but stuttering, jerky, and
unpredictable, and spend the most time waiting, but it is impossible
to tell for how long, and if the wait will even turn out a result. 
Also note that from a computer's viewpoint a human 
can be seen as a very demanding I/O device, making it a good candidate
for a thread to deal with that (but that may be by far not the most
popular take on that matter).

That's where computing leaves academia and hits the sad reality:
Imagine you were writing a virus scanner with a graphical user interface
(you wouldn't want to write such a software, for all the money in
the world, I know, this is just an example) - would you start a task
each time the "scan" button is clicked? No, you would start that task
when the application starts, put it to sleep, and in it wait for orders,
that is what you'd do.
Or rather, that's what I'd do, and I may be completely off the
track, because I would allow the user to enter the configuration
panels and other sections of the program even while such a scan is in
progress:

  local exec = require "tek.lib.exec"
  local c = exec.run(function()
    local exec = require "tek.lib.exec"
    print "your orders please!"
    while true do
      local order, sender = exec.waitmsg()
      print(order, sender)
      if order == "quit" then
        break
      end
    end
  end)
  exec.sleep(1000)
  c:sendmsg("scan")
  exec.sleep(1000)
  c:sendmsg("quit")
  c:join()

To be continued...
