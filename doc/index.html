<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<title>LuaExec</title>
		<link rel="stylesheet" href="manual.css" />
	</head>
	<body>
		<h1>
			LuaExec
		</h1>
		<p>
			Version 0.80
		</p>
		<hr />
		<h3>
			Table of contents
		</h3>
		<blockquote>
			<ul>
				<li style="list-style-type: none">
					1. <a href="#about">About LuaExec</a> 
					<blockquote>
						<ul>
							<li style="list-style-type: none">
								1.1. <a href="#overview">Overview</a> 
							</li>
							<li style="list-style-type: none">
								1.2. <a href="#demarcation">What it does and doesn't</a> 
							</li>
							<li style="list-style-type: none">
								1.3. <a href="#implementation">Implementation details</a> 
							</li>
							<li style="list-style-type: none">
								1.4. <a href="#status">Status, outlook</a> 
							</li>
							<li style="list-style-type: none">
								1.5. <a href="#license">License</a> 
							</li>
							<li style="list-style-type: none">
								1.6. <a href="#links">Authors, links and downloads</a> 
							</li>
						</ul>
					</blockquote>
				</li>
				<li style="list-style-type: none">
					2. <a href="#buildinstall">Installation</a> 
					<blockquote>
						<ul>
							<li style="list-style-type: none">
								2.1. <a href="#requirements">Requirements</a> 
							</li>
							<li style="list-style-type: none">
								2.2. <a href="#buildenv">Adjusting the build environment</a> 
							</li>
							<li style="list-style-type: none">
								2.3. <a href="#builing">Building</a> 
							</li>
							<li style="list-style-type: none">
								2.4. <a href="#installation">Installation</a> 
							</li>
							<li style="list-style-type: none">
								2.5. <a href="#gendoc">Documentation system</a> 
							</li>
						</ul>
					</blockquote>
				</li>
				<li style="list-style-type: none">
					3. <a href="#examples">Examples</a> 
					<blockquote>
						<ul>
							<li style="list-style-type: none">
								3.1 <a href="#tests">Tests</a> 
							</li>
							<li style="list-style-type: none">
								3.2 <a href="#httpserver">HTTP server</a> 
							</li>
						</ul>
					</blockquote>
				</li>
				<li style="list-style-type: none">
					4. <a href="#tutorial">Quickstart tutorial</a> 
				</li>
			</ul>
		</blockquote>
		<h3>
			Reference
		</h3>
		<blockquote>
			<ul>
				<li>
					<a href="manual.html#tek.lib.exec">LuaExec module reference</a> 
				</li>
				<li>
					<a href="manual.html">Complete class and library reference manual</a> 
				</li>
				<li>
					<a href="changes.html">Changelog</a> 
				</li>
				<li>
					<a href="copyright.html">COPYRIGHT</a> 
				</li>
			</ul>
		</blockquote>
		<hr />
		<div class="node"><h2><a name="about" id="about">1. About LuaExec</a></h2>
		</div>
		<div class="node"><h3><a name="overview" id="overview">1.1 Overview</a></h3>
			<p>
				LuaExec is another take on multitasking for Lua.
			</p>
			<p>
				LuaExec is mainly focused on general applicability, simplicity and
				concise semantics. It provides multiple threads of execution in the
				most abstract sense, behaving understandably, platform-independently
				and unencumbered by OS specific details.
			</p>
		</div>
		<div class="node"><h3><a name="demarcation" id="demarcation">1.2 What it does and doesn't</a></h3>
			<blockquote>
				<ul>
					<li>
						runs a Lua interpreter per task
					</li>
					<li>
						is recursive, a child task can itself require the module, run
						child tasks, and see all other tasks
					</li>
					<li>
						data exchange using messages, signals, arguments and return values
					</li>
					<li>
						allows to synchronize on: task completion, signals, messages
					</li>
					<li>
						abstract signals: a, t, c, m (abort, terminate, child, message)
					</li>
					<li>
						tasks can find each other by name or by parent
					</li>
					<li>
						no shared data, no marshalling, this is at the user's discretion
					</li>
					<li>
						no operating system details (e.g. priorities)
					</li>
				</ul>
			</blockquote>
		</div>
		<div class="node"><h3><a name="implementation" id="implementation">1.3 Implementation details</a></h3>
			<blockquote>
				<ul>
					<li>
						LuaExec is a regular module using only the legal Lua API.
					</li>
					<li>
						It should work with Lua 5.1, 5.2, 5.3, and LuaJIT2.0 on POSIX and
						Windows. Not all combinations are fully tested yet.
					</li>
					<li>
						Child tasks are subject to garbage collection in their parent
						that created them. Their underlying OS threads are always joined
						and <em>never killed forcibly</em>, and all resources requested in any
						task are meant to be returned, at the latest through garbage
						collection.
					</li>
					<li>
						A Lua error in a task raises a signal, a (abort), that is by
						default propagated to the parent task.
					</li>
					<li>
						Child tasks and tasks that spawned children are, by default,
						supplied with a debug hook that checks for the abortion signal,
						where it raises an error, signals its parent, and so forth.
					</li>
					<li>
						The hook can be disabled on a per-task basis. In such tasks
						abortion strikes only when they are suspended in wait, sleep etc.
					</li>
				</ul>
			</blockquote>
		</div>
		<div class="node"><h3><a name="status" id="status">1.4. Status, outlook</a></h3>
			<p>
				This project is a prototype and request for comments. Additions,
				suggestions, improvements, bug fixes are likely needed and welcome.
				Performance was no consideration yet. In its current stage LuaExec
				is about getting semantics right. Some considerations:
			</p>
			<blockquote>
				<ul>
					<li>
						Because LuaExec is recursive in that child tasks can create new
						tasks that can see other tasks (and can be seen by other tasks),
						LuaExec could easily provide a shared data or registry mechanism.
						This is currently being investigated.
					</li>
					<li>
						LuaExec's protocol and API should remain (or become) transparent
						as to whether it is implemented as threads or processes, or as
						threads or processes on different hosts.
					</li>
					<li>
						Support for serialization or marshalling
					</li>
					<li>
						Given sufficient interest, this library might be extended in a way
						that other Lua modules and libraries can be written against
						LuaExec's C and Lua APIs, so that future Lua sockets and I/O,
						libraries and applications can converge and be synchronized on
						atomically in a platform-independent, Lua-ish way.
					</li>
				</ul>
			</blockquote>
			<p>
				This project is a spin-off from the
				<a href="http://tekui.neoscientists.org/">tekUI project</a>. The LuaExec 0.80
				module is fully contained in (but usable independently of) tekUI
				version 1.11. The reason for outsourcing was to have a separate
				testbed and package that is unencumbered by the requirements and
				complexity of graphical input and output. There are a few examples
				in this package that can be run against tekUI, and there are a few
				more tasks examples in the tekUI package.
			</p>
		</div>
		<div class="node"><h3><a name="license" id="license">1.5. License</a></h3>
			<p>
				LuaExec is free software under the same license as Lua itself: It can
				be used for both academic and commercial purposes at no cost. It
				qualifies as Open Source software, and its license is compatible with
				the GPL &#8211; see <a href="copyright.html">copyright</a>. Additional components
				are available under a commercial license &#8211; see below.
			</p>
		</div>
		<div class="node"><h3><a name="links" id="links">1.6. Authors, links and downloads</a></h3>
			<p>
				Authors:
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						Timm S. M&#252;ller &lt;tmueller at schulze-mueller.de&gt;
					</li>
				</ul>
			</blockquote>
			<p>
				Open source project website:
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						<a href="http://luaexec.neoscientists.org/">http://luaexec.neoscientists.org/</a> 
					</li>
				</ul>
			</blockquote>
			<p>
				Releases:
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						<a href="http://luaexec.neoscientists.org/releases/">http://luaexec.neoscientists.org/releases/</a> 
					</li>
				</ul>
			</blockquote>
			<p>
				Online source code repository:
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						<a href="http://hg.neoscientists.org/luaexec">http://hg.neoscientists.org/luaexec</a> 
					</li>
				</ul>
			</blockquote>
			<hr />
		</div>
		<div class="node"><h2><a name="buildinstall" id="buildinstall">2. Building and installing</a></h2>
		</div>
		<div class="node"><h3><a name="requirements" id="requirements">2.1. Requirements</a></h3>
			<blockquote>
				<ul>
					<li>
						Lua 5.1, 5.2, 5.3, LuaJIT 2.x
					</li>
					<li>
						GCC or LLVM/clang
					</li>
					<li>
						MinGW for building for the Windows platform
					</li>
				</ul>
			</blockquote>
			<p>
				Only for the webserver example and documentation generator:
				Lua 5.2 and 5.3 must be compiled with <code>LUA_COMPAT_MODULE</code>.
			</p>
			<h4>
				External Lua modules
			</h4>
			<p>
				LuaExec does not strictly depend on any external Lua modules. The
				following modules are supported:
			</p>
			<blockquote>
				<ul>
					<li>
						<a href="http://www.keplerproject.org/luafilesystem/">LuaFileSystem</a> 
						for the HTTP server example and documentation generator
					</li>
					<li>
						<a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a> 
						for the HTTP server example
					</li>
				</ul>
			</blockquote>
		</div>
		<div class="node"><h3><a name="buildenv" id="buildenv">2.2. Adjusting the build environment</a></h3>
			<p>
				If building fails for you, you may have to adjust the build
				environment, which is located in the <code>config</code> file on the topmost
				directory level. Supported build tools are <code>gmake</code> (common under
				Linux) and <code>pmake</code> (common under FreeBSD). More build options and
				peculiarities are documented in the tekUI package, many of which
				apply to the LuaExec package as well.
			</p>
			<h4>
				BSD notes
			</h4>
			<p>
				On FreeBSD and NetBSD you need a Lua binary which is linked with the
				<code>-pthread</code> option, as LuaExec is using multithreaded code in shared
				libraries, which are dynamically loaded by the interpreter.
			</p>
		</div>
		<div class="node"><h3><a name="building" id="building">2.3. Building</a></h3>
			<p>
				To see all build targets, type
			</p>
<pre>
# make help
</pre>
			<p>
				The regular build procedure is invoked with
			</p>
<pre>
# make all
</pre>
		</div>
		<div class="node"><h3><a name="installation" id="installation">2.4. Installation</a></h3>
			<p>
				A system-wide installation of LuaExec is not strictly required. Once
				it is built, it can be worked with and developed against, as long as
				you stay in the top-level directory of the distribution; all required
				modules will be found if programs are started from there.
			</p>
			<p>
				If staying in the top-level directory is not desirable, then LuaExec
				must be installed globally. By default, the installation paths are
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						<code>/usr/local/lib/lua/5.1</code> 
					</li>
					<li style="list-style-type: none">
						<code>/usr/local/share/lua/5.1</code> 
					</li>
				</ul>
			</blockquote>
			<p>
				It is not unlikely that this is different from what is common for
				your operating system, distribution or development needs, so be sure
				to adjust these paths in the <code>config</code> file. The installation is
				conveniently invoked with
			</p>
<pre>
# sudo make install
</pre>
		</div>
		<div class="node"><h3><a name="gendoc" id="gendoc">2.5 Documentation system</a></h3>
			<p>
				LuaExec comes with a documentation generator. It is capable of
				generating a function reference and hierarchical class index from
				specially crafted comments in the source code. To regenerate the
				full documentation, invoke
			</p>
<pre>
# make docs
</pre>
			<p>
				Note that you need
				<a href="http://www.keplerproject.org/luafilesystem/">LuaFileSystem</a> for
				the document generator to process the file system hierarchy.
			</p>
			<hr />
		</div>
		<div class="node"><h2><a name="examples" id="examples">3. Examples</a></h2>
		</div>
		<div class="node"><h3><a name="tests" id="tests">3.1 Tests</a></h3>
			<p>
				Tests are under <code>bin/task/</code>.
			</p>
		</div>
		<div class="node"><h3><a name="httpserver" id="httpserver">3.2 HTTP Server example</a></h3>
			<p>
				One of the use cases LuaExec was developed against was to supply
				a regular Lua application with an inbuilt HTTP server. It can be
				run in the background like this:
			</p>
<pre>
local exec = require &quot;tek.lib.exec&quot;
local httpd = exec.run(function()
  require &quot;tek.class.httpd&quot;:new {
    Listen = arg&#091;1&#093;, DocumentRoot = &quot;doc&quot;
  }:run()
end, arg&#091;1&#093; or &quot;localhost:8080&quot;)
-- ... do something else ...
httpd:terminate() -- or httpd:join()
</pre>
			<p>
				To start it serving LuaExec's documentation (default localhost:8080):
			</p>
<pre>
# bin/webserver.lua &#091;host:port&#093;
</pre>
			<p>
				It requires luasocket and lfs. The server itself is not
				multithreaded, due to limitations of the current Lua library
				ecosystem, but it supports copas/coxpcall if available.
			</p>
			<p>
				These links should work when you have loaded this document from the
				provided HTTP server:
			</p>
			<blockquote>
				<ul>
					<li>
						CGI test page: <a href="/webserver/testcgi.lua">/webserver/testcgi.lua</a> 
					</li>
					<li>
						Formtest Lua page: <a href="/webserver/formtest.lhtml">/webserver/formtest.lhtml</a> 
					</li>
					<li>
						Webserver control Lua page: <a href="/webserver/control.lhtml">/webserver/control.lhtml</a> 
					</li>
				</ul>
			</blockquote>
			<p>
				Please note that the HTTP/1.1 part of the server was not thoroughly
				written against specifications. It is included as an example.
			</p>
			<hr />
		</div>
		<div class="node"><h2><a name="tutorial" id="tutorial">4. Quickstart tutorial</a></h2>
			<p>
				For the first part of this tutorial, please use Lua in interactive
				mode, because this is going to be fun, and hopefully instructive!
				Start off by requiring the LuaExec module:
			</p>
<pre>
# lua
&gt; exec = require &quot;tek.lib.exec&quot;
</pre>
			<p>
				What's our task's name?
			</p>
<pre>
&gt; print(exec.getname())
=&gt; main
</pre>
			<p>
				Sleep a second (1000 milliseconds):
			</p>
<pre>
&gt; exec.sleep(1000)
</pre>
			<p>
				Now to starting a new task:
			</p>
<pre>
&gt; exec.run(function() end)
=&gt;
</pre>
			<p>
				Nothing happened? Well, it probably just ran and exited.
				Let's have it do something:
			</p>
<pre>
&gt; exec.run(function() print &quot;hello&quot; end)
=&gt; hello
</pre>
			<p>
				Seems reasonable. Now let's have it do some work:
			</p>
<pre>
&gt; exec.run(function() while true do end end)
</pre>
			<p>
				So far, so good. Do you notice some change in the behavior of your
				computer? Probably not. Ok, then try it again...
			</p>
<pre>
&gt; exec.run(function() while true do end end)
</pre>
			<p>
				Still nothing? Then try this:
			</p>
<pre>
&gt; for i = 1, 4 do exec.run(function() while true do end end) end
</pre>
			<p>
				Some fans spinning up possibly?
			</p>
			<p>
				I think it's time to quit interactive mode now rather quickly.
				I hope your Lua interpreter has proper interactive mode, so that
				it is orderly closed down and you see the intended effect.
				Press CTRL-D now (not CTRL-C):
			</p>
<pre>
&gt;
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
luatask: received abort signal
stack traceback:
        stdin:1: in function &lt;stdin:1&gt;
        &#091;C&#093;: ?
</pre>
		</div>
	<p>
		Each of the tasks started above running an infinite loop should now
		receive an abortion signal from Lua closing down and performing
		garbage collection. This causes each task to raise an error, and
		consequently to report that error. This is a very important
		aspect of LuaExec. (And by dissipating heat we just may have helped
		the universe to approach its destiny a little sooner, but this
		remains to be seen.)
	</p>
	<p>
		The next examples are performed in scripts. To reiterate
		what was said above, run the following script. You'll get a stack trace from the child that was running,
		because it did not finish voluntarily when the main program
		was ending:
	</p>
<pre>
local exec = require &quot;tek.lib.exec&quot;
exec.run(function()
  while true do end
end)
=&gt;
luatask: received abort signal
stack traceback:
        bin/tutorial.lua:3: in function &lt;bin/tutorial.lua:2&gt;
        &#091;C&#093;: ?
</pre>
	<p>
		On the other hand, if it <em>does</em> shut down voluntarily, everything
		remains silent:
	</p>
<pre>
local exec = require &quot;tek.lib.exec&quot;
exec.run(function()
  print &quot;hello&quot;
end)
exec.sleep(100)
=&gt;
</pre>
	<p>
		I have added the last line to drive home that message, because your
		friggin' operating system could theoretically decide to postpone
		execution of the child task a bit, and we ended up with an error
		and stracktrace nonetheless.
	</p>
	<p>
		Note that although this is the plushy world of Lua, and LuaExec tries
		its best to hide the nastiness of multithreaded programming from you,
		trailing behind a bunch of dangling threads is by no means an
		encouraged programming technique. What <em>is</em> encouraged is that you
		synchronize on the end of the thread. This also allows you to take
		delivery of return values:
	</p>
<pre>
local exec = require &quot;tek.lib.exec&quot;
local c = exec.run(function()
  return &quot;successful&quot;, &quot;indeed&quot;
end)
print(c:join())
=&gt;
true    successful      indeed
</pre>
	<p>
		Next we should ask ourselves what threads are actually good for.
		Especially in the Lua world this seems to be hotly debated -
	</p>
	<p>
		In computations, actually, it is difficult to put them to good use,
		but matters improved a bit in that regard, with projects like
		SETI@home, digging for bitcoins, and so on. There are enough
		CPU cycles to be wasted in fun computations, especially if you run
		them in a scripting language. Wouldn't it be a pity if we couldn't
		saturate eight cores from a small Lua script?
	</p>
	<p>
		Irony aside, threads have always been useful for long-running
		tasks, regardless of their computational demand, and they are
		even more useful if they are bound to I/O operations that are precisely
		<em>not</em> computationally demanding, but stuttering, jerky, and
		unpredictable, and spend the most time waiting, but it is impossible
		to tell for how long, and if the wait will even turn out a result.
		Also note that from a computer's viewpoint a human
		can be seen as a very demanding I/O device, making it a good candidate
		for a thread to deal with that (but that may be by far not the most
		popular take on that matter).
	</p>
	<p>
		That's where computing leaves academia and hits the sad reality:
		Imagine you were writing a virus scanner with a graphical user interface
		(you wouldn't want to write such a software, for all the money in
		the world, I know, this is just an example) - would you start a task
		each time the &quot;scan&quot; button is clicked? No, you would start that task
		when the application starts, put it to sleep, and in it wait for orders,
		that is what you'd do.
		Or rather, that's what I'd do, and I may be completely off the
		track, because I would allow the user to enter the configuration
		panels and other sections of the program even while such a scan is in
		progress:
	</p>
<pre>
local exec = require &quot;tek.lib.exec&quot;
local c = exec.run(function()
  local exec = require &quot;tek.lib.exec&quot;
  print &quot;your orders please!&quot;
  while true do
    local order, sender = exec.waitmsg()
    print(order, sender)
    if order == &quot;quit&quot; then
      break
    end
  end
end)
exec.sleep(1000)
c:sendmsg(&quot;scan&quot;)
exec.sleep(1000)
c:sendmsg(&quot;quit&quot;)
c:join()
</pre>
	<p>
		To be continued...
	</p>
	</body>
</html>
